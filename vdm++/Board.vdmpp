class Board
	types
	values
	-- TODO Define values here
	instance variables
		private positions : map Piece`Position to Piece;
		private arrows : seq of Arrow := []; 
		inv card {a | a in set (rng positions) & isofclass(Amazon, a)} = 8;
	operations
		public Board: () ==> Board
			Board() == (
				dcl w1: Amazon := new Amazon(0, 3, <White>);
				dcl w2: Amazon := new Amazon(3, 0, <White>);
				dcl w3: Amazon := new Amazon(9, 3, <White>);
				dcl w4: Amazon := new Amazon(6, 0, <White>);
				dcl b1: Amazon := new Amazon(0, 6, <Black>);
				dcl b2: Amazon := new Amazon(3, 9, <Black>);
				dcl b3: Amazon := new Amazon(6, 9, <Black>);
				dcl b4: Amazon := new Amazon(9, 6, <Black>);
				positions := {mk_Piece`Position(0,3) |-> w1,
											mk_Piece`Position(3,0) |-> w2,
											mk_Piece`Position(9,3) |-> w3,
											mk_Piece`Position(6,0) |-> w4,
											mk_Piece`Position(0,6) |-> b1,
											mk_Piece`Position(3,9) |-> b2,
											mk_Piece`Position(6,9) |-> b3,
											mk_Piece`Position(9,6) |-> b4
											};
			);
			
		-- move : moves a amazon on the board
		public move : nat * nat * nat * nat ==> ()
			move(x, y, new_x, new_y) == (	
				dcl amazon:Amazon := positions(mk_Piece`Position(x,y));
				amazon.setX(new_x);
				amazon.setY(new_y);
				positions := {mk_Piece`Position(x, y)} <-: positions;
				positions := positions ++ {mk_Piece`Position(new_x, new_y) |-> amazon}
			)
			pre mk_Piece`Position(x, y) in set dom positions
				and mk_Piece`Position(new_x, new_y) not in set dom positions
				and isofclass(Amazon ,positions(mk_Piece`Position(x,y)))
				and moveIsValid(x, y, new_x, new_y) 
				and pathIsFree(x,y, new_x, new_y);
					
		-- patIsFree : check if the path is fre
		public pathIsFree : nat * nat * nat * nat ==> bool
			pathIsFree(x, y, new_x, new_y) == (	
				dcl deltaX:nat := new_x - x;
				dcl deltaY:nat := new_y - y;
				dcl pathPieces: set of Piece`Position ;
				if(deltaX = 0 and deltaY > 0) then (
					pathPieces := {a | a in set (dom positions) & a.y in set ({y,...,new_y} \ {y,new_y})};
				) else if(deltaY = 0 and deltaX > 0) then (
					pathPieces := {a | a in set (dom positions) & a.x in set ({x,...,new_x} \ {x,new_x})};
				) else if(deltaX = deltaY and deltaX > 0) then (
					pathPieces := {a | a in set (dom positions) & a.x in set ({x,...,new_x} \ {x,new_x}) and 
														 a.y in set ({y,...,new_y} \ {y,new_y}) and abs(a.x - x) = abs(a.y - y) };
				);
				return card pathPieces = 0;
			) 
			
	functions
		public moveIsValid : nat * nat * nat * nat -> bool
			moveIsValid(x, y, new_x, new_y) == (
				let deltaX, deltaY:nat in
				(
					deltaX = abs(new_x - x) and
					deltaY = abs(new_y - y) and
					(deltaX = 0 and deltaY > 0) or (deltaX > 0 and deltaY = 0) or (deltaX = deltaY and deltaX > 0)	
				)
			);
	traces
end Board